// server.js
const express = require('express');
const axios = require('axios');
const fs = require('fs').promises;
const fsSync = require('fs');
const { execSync, spawn } = require('child_process');
const { Storage } = require('@google-cloud/storage');
const path = require('path');

const app = express();
app.use(express.json({ limit: '200mb' }));

const storage = new Storage();
const BUCKET = process.env.BUCKET_NAME || '';
const RENDER_SECRET = process.env.RENDER_SECRET || 'change_me';

// small helpers
function runFFmpeg(args) {
  return new Promise((resolve, reject) => {
    const ff = spawn('ffmpeg', args, { stdio: 'inherit' });
    ff.on('close', code => (code === 0 ? resolve() : reject(new Error('ffmpeg exit code ' + code))));
  });
}

async function uploadToGCS(localPath, destName) {
  if (!BUCKET) throw new Error('BUCKET_NAME not set in env');
  const bucket = storage.bucket(BUCKET);
  await bucket.upload(localPath, { destination: destName });
  const file = bucket.file(destName);
  const expiresDate = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
  const [signedUrl] = await file.getSignedUrl({ version: 'v4', action: 'read', expires: expiresDate });
  return signedUrl;
}

function secToAss(tSec) {
  const h = Math.floor(tSec / 3600);
  const m = Math.floor((tSec % 3600) / 60);
  const s = Math.floor(tSec % 60);
  const cs = Math.floor((tSec - Math.floor(tSec)) * 100);
  return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
}

function cssToAssColor(hex) {
  if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) return '&H00FFFFFF';
  let r,g,b;
  if (hex.length === 7) { r = hex.substring(1,3); g = hex.substring(3,5); b = hex.substring(5,7); }
  else { r = hex[1]+hex[1]; g = hex[2]+hex[2]; b = hex[3]+hex[3]; }
  return `&H00${b}${g}${r}`.toUpperCase();
}

async function getVideoResolution(inputPath) {
  try {
    const out = execSync(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "${inputPath}"`).toString().trim();
    const [w,h] = out.split(',');
    return { width: parseInt(w,10), height: parseInt(h,10) };
  } catch (e) {
    console.warn('ffprobe failed; using fallback 1920x1080');
    return { width: 1920, height: 1080 };
  }
}

/**
 * framesToAss(frames, styles, videoWidth, videoHeight)
 *
 * Goal:
 * - Keep the bottom line (line2) anchored to paddingBottom (scaled).
 * - Place top line (line1) above it so it DOES NOT push the bottom line.
 * - Ensure both lines are horizontally centered around the same X (use \an5 anchor inside overrides).
 *
 * Notes:
 * - uses small heuristic based on scaled font sizes to approximate visual baselines.
 * - you can tweak `baselineFactorBottom` / `baselineFactorTop` / `extraGapFactor` if you want different spacing.
 */
function framesToAss(frames, styles, videoWidth, videoHeight) {
  const playResX = videoWidth;
  const playResY = videoHeight;
  const referenceHeight = 1080;

  // fonts & sizes
  const fontTop = (styles && styles.fontTop) || 'Lexend';
  const fontBottom = (styles && styles.fontBottom) || 'Cormorant Garamond';
  const fontSizeTop = (styles && styles.fontSizeTop) || 64;
  const fontSizeBottom = (styles && styles.fontSizeBottom) || 100;
  const colorTop = cssToAssColor(styles && styles.colorTop);
  const colorBottom = cssToAssColor(styles && styles.colorBottom);
  const boldTop = (styles && styles.fontWeightTop === '700') ? '1' : '0';
  const boldBottom = (styles && styles.fontWeightBottom === '700') ? '1' : '0';
  const italicTop = (styles && styles.isItalicTop) ? '1' : '0';
  const italicBottom = (styles && styles.isItalicBottom) ? '1' : '0';
  const paddingBottom = (styles && styles.paddingBottom) || 200;

  // scale to actual video height
  const scale = playResY / referenceHeight;
  const scaledTop = fontSizeTop * scale;
  const scaledBottom = fontSizeBottom * scale;
  const baseGap = 12 * scale; // minimal visual gap

  // Heuristic: fonts have different visual baselines. These factors approximate the portion of font-size
  // between baseline and glyph top/bottom that visually matters. Tweak if you want closer/farther spacing.
  const baselineFactorBottom = 0.55; // how much of bottom font height to reserve above its baseline
  const baselineFactorTop = 0.35; // how much of top font extends above its baseline
  const extraGapFactor = 0.15; // small extra separation as fraction of bottom font size

  // compute actual positions
  const Y_pos_Line2 = playResY - (paddingBottom * scale); // bottom anchored (measured from top)
  // top Y: move up by (portion of bottom font height) + (portion of top font height) + baseGap
  const Y_pos_Line1 = Y_pos_Line2 - (scaledBottom * baselineFactorBottom) - (scaledTop * baselineFactorTop) - (baseGap + scaledBottom * extraGapFactor);

  // ASS header
  const shadowColor = '&H80000000';
  const header = `[Script Info]
ScriptType: v4.00+
PlayResX: ${playResX}
PlayResY: ${playResY}
WrapStyle: 0
Title: Generated by AiVideoCaptioner

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: STYLE_BOTTOM,${fontBottom},${fontSizeBottom},${colorBottom},${colorBottom},&H00000000,${shadowColor},${boldBottom},${italicBottom},0,0,100,100,0,0,1,0,2,2,20,20,0,1
Style: STYLE_TOP,${fontTop},${fontSizeTop},${colorTop},${colorTop},&H00000000,${shadowColor},${boldTop},${italicTop},0,0,100,100,0,0,1,0,2,2,20,20,0,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  const events = frames.flatMap(f => {
    const startSec = (f.start || 0) / 1000;
    const endSec = (f.end || ( (f.start || 0) + 2000 )) / 1000;
    const assStart = secToAss(startSec);
    const assEnd = secToAss(endSec);
    const out = [];

    // NOTE: using override {\an5\pos(x,y)} forces the *center* of the text to be at x,y (consistent anchor)
    // this avoids reliance on style alignment which sometimes produces different origin points.
    const centerX = Math.round(playResX / 2);

    if (f.line1 && f.line1.trim() !== '') {
      // escape ASS reserved chars minimally (commonly used): replace newline -> \N (we keep other chars as-is)
      const t1 = f.line1.trim().replace(/\n/g, '\\N');
      out.push(`Dialogue: 0,${assStart},${assEnd},STYLE_TOP,,0,0,0,,{\\an5\\pos(${centerX},${Math.round(Y_pos_Line1)})}${t1}`);
    }

    if (f.line2 && f.line2.trim() !== '') {
      const t2 = f.line2.trim().replace(/\n/g, '\\N');
      out.push(`Dialogue: 0,${assStart},${assEnd},STYLE_BOTTOM,,0,0,0,,{\\an5\\pos(${centerX},${Math.round(Y_pos_Line2)})}${t2}`);
    }

    return out;
  }).join('\n');

  return header + events;
}

// -------------------------
// /render endpoint
// -------------------------
app.post('/render', async (req, res) => {
  try {
    const headerSecret = req.header('X-Render-Secret');
    const bodySecret = req.body && req.body.render_secret;
    const provided = headerSecret || bodySecret || '';
    if (provided !== RENDER_SECRET) return res.status(401).json({ status: 'error', error: 'unauthorized' });

    const { job_id, video_url, frames, style, callback_url, watermark_url, plan_tier } = req.body || {};
    if (!video_url || !frames) return res.status(400).json({ status: 'error', error: 'missing fields - require video_url and frames' });

    const shouldAddWatermark = plan_tier === 'free';
    const tmpDir = '/tmp';
    const inputPath = path.join(tmpDir, `in-${job_id}.mp4`);
    const assPath = path.join(tmpDir, `subs-${job_id}.ass`);
    const watermarkPath = path.join(tmpDir, `watermark-${job_id}.png`);
    const outPath = path.join(tmpDir, `out-${job_id}.mp4`);

    // download video
    try {
      console.log(`Downloading ${video_url}`);
      const writer = (await axios({ url: video_url, method: 'GET', responseType: 'stream' })).data;
      const outStream = fsSync.createWriteStream(inputPath);
      await new Promise((resolve, reject) => {
        writer.pipe(outStream);
        writer.on('end', resolve);
        writer.on('error', reject);
      });
    } catch (e) {
      let msg = 'Failed to download video. Check URL/permissions.';
      if (e.response && e.response.status === 403) msg = `Video download failed with HTTP 403 Forbidden. Ensure the video URL is publicly accessible.`;
      console.error('Download error:', e.message || e);
      return res.status(500).json({ status: 'error', error: msg });
    }

    // detect resolution
    const videoResolution = await getVideoResolution(inputPath);
    console.log('Detected resolution:', videoResolution);

    // download watermark (optional)
    let watermarkInput = null;
    if (shouldAddWatermark && watermark_url) {
      try {
        const logoWriter = (await axios({ url: watermark_url, method: 'GET', responseType: 'stream' })).data;
        const logoOutStream = fsSync.createWriteStream(watermarkPath);
        await new Promise((resolve, reject) => {
          logoWriter.pipe(logoOutStream);
          logoOutStream.on('close', resolve);
          logoOutStream.on('error', reject);
        });
        watermarkInput = watermarkPath;
      } catch (e) {
        console.warn('watermark download failed; falling back to text watermark:', e.message || e);
      }
    }

    // generate ASS using actual resolution
    const ass = framesToAss(frames, style, videoResolution.width, videoResolution.height);
    await fs.writeFile(assPath, ass, 'utf8');

    // build ffmpeg args
    const assFilter = `ass=filename=${assPath}:fontsdir=/app/fonts`;
    let ffArgs;
    if (shouldAddWatermark) {
      if (watermarkInput) {
        // watermark image overlay then ASS
        const filter = `[0:v]scale=-1:28[wm];[1:v][wm]overlay=x=main_w-overlay_w-24:y=24[v_wm];[v_wm]${assFilter}[v]`;
        ffArgs = ['-y', '-i', watermarkInput, '-i', inputPath, '-filter_complex', filter, '-map', '[v]', '-map', '1:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
      } else {
        // drawtext watermark then ASS
        const textDraw = `drawtext=fontfile='Lexend-Regular.ttf':text='AiVideoCaptioner':fontsize=18:fontcolor=white@0.7:x=main_w-tw-24:y=24[v_wm]`;
        const filter = `[0:v]${textDraw};[v_wm]${assFilter}[v]`;
        ffArgs = ['-y', '-i', inputPath, '-filter_complex', filter, '-map', '[v]', '-map', '0:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
      }
    } else {
      const filter = `[0:v]${assFilter}[v]`;
      ffArgs = ['-y', '-i', inputPath, '-filter_complex', filter, '-map', '[v]', '-map', '0:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
    }

    // run ffmpeg
    try {
      await runFFmpeg(ffArgs);
    } catch (ffErr) {
      console.error('ffmpeg failed:', ffErr);
      return res.status(500).json({ status: 'error', error: 'ffmpeg failed: ' + (ffErr.message || ffErr) });
    }

    // upload
    const destName = `renders/${job_id}-${Date.now()}.mp4`;
    let publicUrl;
    try {
      publicUrl = await uploadToGCS(outPath, destName);
    } catch (uerr) {
      console.error('upload failed:', uerr);
      return res.status(500).json({ status: 'error', error: 'upload failed: ' + (uerr.message || uerr) });
    }

    // callback (best-effort)
    if (callback_url) {
      try {
        await axios.post(callback_url, { render_secret: RENDER_SECRET, job_id, status: 'success', video_url: publicUrl }, { timeout: 10000 });
      } catch (e) {
        console.warn('Callback failed (non-fatal):', e.message || e);
      }
    }

    return res.json({ status: 'success', job_id, video_url: publicUrl });
  } catch (err) {
    console.error('Server error (catch-all):', err);
    return res.status(500).json({ status: 'error', error: err.message || String(err) });
  }
});

const port = process.env.PORT || 8080;
app.listen(port, () => console.log('listening on', port));
