// server.js (final robust 360p-baseline scaling version)
const express = require('express');
const axios = require('axios');
const fs = require('fs').promises;
const fsSync = require('fs');
const { spawn, execSync } = require('child_process');
const { Storage } = require('@google-cloud/storage');
const path = require('path');

const app = express();
app.use(express.json({ limit: '300mb' }));

const storage = new Storage();
const BUCKET = process.env.BUCKET_NAME || '';
const RENDER_SECRET = process.env.RENDER_SECRET || 'change_me';
const SYSTEM_FONTS_DIR = process.env.SYSTEM_FONTS_DIR || '/usr/local/share/fonts/custom';
const TMP_DIR = '/tmp';

// -------------------- Utilities --------------------
function secToAss(tSec) {
  tSec = isFinite(tSec) ? tSec : 0;
  const h = Math.floor(tSec / 3600);
  const m = Math.floor((tSec % 3600) / 60);
  const s = Math.floor(tSec % 60);
  const cs = Math.floor((tSec - Math.floor(tSec)) * 100);
  return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
}

function cssToAssColor(hex) {
  if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) return '&H00FFFFFF';
  let r,g,b;
  if (hex.length === 7) { r = hex.substring(1,3); g = hex.substring(3,5); b = hex.substring(5,7); }
  else { r = hex[1]+hex[1]; g = hex[2]+hex[2]; b = hex[3]+hex[3]; }
  return `&H00${b}${g}${r}`.toUpperCase();
}

function escapeAssText(s) {
  if (!s && s !== 0) return '';
  let t = String(s).trim();
  t = t.replace(/\r\n?/g, '\n').replace(/\n/g, '\\N');
  t = t.replace(/\\/g, '\\\\').replace(/{/g, '\\{').replace(/}/g, '\\}');
  t = t.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');
  return t;
}

async function getVideoResolution(inputPath) {
  try {
    const out = execSync(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "${inputPath}"`).toString().trim();
    const [w,h] = out.split(',');
    return { width: parseInt(w,10) || 1920, height: parseInt(h,10) || 1080 };
  } catch {
    console.warn('ffprobe failed; using fallback 1920x1080');
    return { width: 1920, height: 1080 };
  }
}

function runFFmpeg(args) {
  return new Promise((resolve, reject) => {
    console.log('Spawning ffmpeg:', args.join(' '));
    const ff = spawn('ffmpeg', args, { stdio: ['ignore', 'pipe', 'pipe'] });
    let stderr = '';
    ff.stderr.on('data', d => { stderr += d.toString(); });
    ff.on('close', code => {
      if (code === 0) resolve({ stderr });
      else {
        const err = new Error(`ffmpeg exited ${code}\n${stderr}`);
        reject(err);
      }
    });
  });
}

// -------------------- ASS Generator (360p baseline scaling) --------------------
function framesToAss(frames, styles = {}, videoWidth = 1920, videoHeight = 1080) {
  // 360p baseline
  const BASELINE_HEIGHT = 360;
  const scale = (videoHeight || BASELINE_HEIGHT) / BASELINE_HEIGHT;

  const rawFontTop = styles.fontSizeTop || 40;      // baseline for 360p
  const rawFontBottom = styles.fontSizeBottom || 52; // baseline for 360p

  const fontSizeTop = Math.max(18, Math.min(380, Math.round(rawFontTop * scale)));
  const fontSizeBottom = Math.max(20, Math.min(420, Math.round(rawFontBottom * scale)));

  const fontTop = (styles.fontTop || 'Lexend').replace(/,/g,'');
  const fontBottom = (styles.fontBottom || 'Cormorant Garamond').replace(/,/g,'');

  const colorTop = cssToAssColor(styles.colorTop || '#FFFFFF');
  const colorBottom = cssToAssColor(styles.colorBottom || '#FFD100');
  const boldTop = (styles.fontWeightTop === '700' || styles.fontWeightTop === 700) ? '1' : '0';
  const boldBottom = (styles.fontWeightBottom === '700' || styles.fontWeightBottom === 700) ? '1' : '0';
  const italicTop = styles.isItalicTop ? '1' : '0';
  const italicBottom = styles.isItalicBottom ? '1' : '0';

  // padding also scaled from 360p baseline
  const basePad = styles.paddingBottom != null ? styles.paddingBottom : 120;
  const padScaled = Math.round(basePad * scale);

  const baselineFactorBottom = 0.66;
  const baselineFactorTop = 0.28;
  const baseGap = Math.round(20 * scale);
  const extraGapFactor = 0.22;

  let Y_pos_Line2 = videoHeight - padScaled;
  const twoLinePresent = frames.some(f => f.line1 && f.line1.trim() && f.line2 && f.line2.trim());
  if (twoLinePresent) Y_pos_Line2 += Math.round(fontSizeBottom * 0.28);

  const Y_pos_Line1 = Y_pos_Line2
    - (fontSizeBottom * baselineFactorBottom)
    - (fontSizeTop * baselineFactorTop)
    - (baseGap + fontSizeBottom * extraGapFactor);

  const header = `[Script Info]
ScriptType: v4.00+
PlayResX: ${videoWidth}
PlayResY: ${videoHeight}
WrapStyle: 0
Title: Generated by AiVideoCaptioner

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: STYLE_BOTTOM,${fontBottom},${fontSizeBottom},${colorBottom},${colorBottom},&H00000000,&H80000000,${boldBottom},${italicBottom},0,0,100,100,0,0,1,0,2,2,${padScaled},20,0,1
Style: STYLE_TOP,${fontTop},${fontSizeTop},${colorTop},${colorTop},&H00000000,&H80000000,${boldTop},${italicTop},0,0,100,100,0,0,1,0,2,2,${padScaled},20,0,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  const centerX = Math.round(videoWidth / 2);
  const events = frames.flatMap(f => {
    const startMs = Number.isFinite(f.start) ? f.start : 0;
    const endMs = Number.isFinite(f.end) ? f.end : startMs + 2000;
    const s = secToAss(startMs / 1000);
    const e = secToAss(endMs / 1000);
    const out = [];
    if (f.line1 && f.line1.trim()) {
      const t1 = escapeAssText(f.line1);
      out.push(`Dialogue: 0,${s},${e},STYLE_TOP,,0,0,0,,{\\an5\\pos(${centerX},${Math.round(Y_pos_Line1)})}${t1}`);
    }
    if (f.line2 && f.line2.trim()) {
      const t2 = escapeAssText(f.line2);
      out.push(`Dialogue: 0,${s},${e},STYLE_BOTTOM,,0,0,0,,{\\an5\\pos(${centerX},${Math.round(Y_pos_Line2)})}${t2}`);
    }
    return out;
  }).join('\n');

  console.log(`Font scaling for ${videoHeight}p â†’ top=${fontSizeTop}, bottom=${fontSizeBottom}`);
  return header + events;
}

// -------------------- GCS Upload --------------------
async function uploadToGCS(localPath, destName) {
  if (!BUCKET) throw new Error('BUCKET_NAME not set');
  const bucket = storage.bucket(BUCKET);
  await bucket.upload(localPath, { destination: destName });
  const file = bucket.file(destName);
  const expiresDate = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
  const [signedUrl] = await file.getSignedUrl({ version: 'v4', action: 'read', expires: expiresDate });
  return signedUrl;
}

// -------------------- /render endpoint --------------------
app.post('/render', async (req, res) => {
  try {
    const headerSecret = req.header('X-Render-Secret');
    const provided = headerSecret || req.body?.render_secret || '';
    if (provided !== RENDER_SECRET) return res.status(401).json({ status: 'error', error: 'unauthorized' });

    let { job_id, video_url, frames, style, callback_url, watermark_url, plan_tier } = req.body || {};
    if (typeof style === 'string') try { style = JSON.parse(style); } catch {}

    if (!video_url || !job_id) return res.status(400).json({ status: 'error', error: 'missing fields' });

    const inputPath = path.join(TMP_DIR, `in-${job_id}.mp4`);
    const assPath = path.join(TMP_DIR, `subs-${job_id}.ass`);
    const outPath = path.join(TMP_DIR, `out-${job_id}.mp4`);

    // Download video
    const response = await axios({ url: video_url, method: 'GET', responseType: 'stream', timeout: 20000 });
    const writer = fsSync.createWriteStream(inputPath);
    await new Promise((resv, rej) => { response.data.pipe(writer); writer.on('finish', resv); writer.on('error', rej); });
    console.log('Downloaded video.');

    const { width, height } = await getVideoResolution(inputPath);
    console.log('Detected resolution:', width, height);

    // Generate ASS
    const ass = framesToAss(frames || [], style || {}, width, height);
    await fs.writeFile(assPath, ass, 'utf8');
    console.log('Wrote ASS file.');

    // Prepare ffmpeg
    const quotedAss = assPath.replace(/'/g, "\\'");
    const quotedFonts = SYSTEM_FONTS_DIR.replace(/'/g, "\\'");
    const assFilter = `ass=filename='${quotedAss}':fontsdir='${quotedFonts}'`;

    const shouldAddWatermark = plan_tier === 'free';
    const WATERMARK_TEXT = 'AiVideoCaptioner';
    const PADDING = 20;

    let ffArgs, filterComplex;

    if (shouldAddWatermark && watermark_url) {
      const watermarkPath = path.join(TMP_DIR, `wm-${job_id}.png`);
      try {
        const wm = await axios({ url: watermark_url, method: 'GET', responseType: 'stream' });
        const wOut = fsSync.createWriteStream(watermarkPath);
        await new Promise((r, e) => { wm.data.pipe(wOut); wOut.on('finish', r); wOut.on('error', e); });
        filterComplex = `[0:v]scale=-1:28[wm];[1:v][wm]overlay=x=main_w-overlay_w-${PADDING}:y=${PADDING}[v];[v]${assFilter}[outv]`;
        ffArgs = ['-y', '-i', watermarkPath, '-i', inputPath, '-filter_complex', filterComplex, '-map', '[outv]', '-map', '1:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
      } catch (e) {
        console.warn('Watermark download failed:', e.message);
      }
    }

    if (!ffArgs) {
      filterComplex = `[0:v]${assFilter}[outv]`;
      ffArgs = ['-y', '-i', inputPath, '-filter_complex', filterComplex, '-map', '[outv]', '-map', '0:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
    }

    console.log('filterComplex:', filterComplex);
    await runFFmpeg(ffArgs);
    console.log('ffmpeg complete.');

    const destName = `renders/${job_id}-${Date.now()}.mp4`;
    const publicUrl = await uploadToGCS(outPath, destName);
    console.log('Uploaded to GCS.');

    if (callback_url) {
      try {
        await axios.post(callback_url, { render_secret: RENDER_SECRET, job_id, status: 'success', video_url: publicUrl }, { timeout: 10000 });
      } catch (e) { console.warn('Callback failed:', e.message); }
    }

    return res.json({ status: 'success', job_id, video_url: publicUrl });
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ status: 'error', error: err.message || String(err) });
  }
});

const port = process.env.PORT || 8080;
app.listen(port, () => console.log('Listening on', port));
