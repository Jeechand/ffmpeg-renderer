// server.js
const express = require('express');
const axios = require('axios');
const fs = require('fs').promises;
const fsSync = require('fs');
const { execSync, spawn } = require('child_process');
const { Storage } = require('@google-cloud/storage');
const path = require('path');

const app = express();
app.use(express.json({ limit: '200mb' }));

const storage = new Storage();
const BUCKET = process.env.BUCKET_NAME || '';
const RENDER_SECRET = process.env.RENDER_SECRET || 'change_me';

// -------------------------
// Utilities
// -------------------------
function runFFmpeg(args) {
  return new Promise((resolve, reject) => {
    const ff = spawn('ffmpeg', args, { stdio: 'inherit' });
    ff.on('close', code => (code === 0 ? resolve() : reject(new Error('ffmpeg exit code ' + code))));
  });
}

async function uploadToGCS(localPath, destName) {
  if (!BUCKET) throw new Error('BUCKET_NAME not set in env');
  const bucket = storage.bucket(BUCKET);
  await bucket.upload(localPath, { destination: destName });
  const file = bucket.file(destName);
  const expiresDate = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
  const [signedUrl] = await file.getSignedUrl({ version: 'v4', action: 'read', expires: expiresDate });
  return signedUrl;
}

function secToAss(tSec) {
  const h = Math.floor(tSec / 3600);
  const m = Math.floor((tSec % 3600) / 60);
  const s = Math.floor(tSec % 60);
  const cs = Math.floor((tSec - Math.floor(tSec)) * 100);
  return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(cs).padStart(2,'0')}`;
}

function cssToAssColor(hex) {
  if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) return '&H00FFFFFF';
  let r,g,b;
  if (hex.length === 7) { r = hex.substring(1,3); g = hex.substring(3,5); b = hex.substring(5,7); }
  else { r = hex[1]+hex[1]; g = hex[2]+hex[2]; b = hex[3]+hex[3]; }
  return `&H00${b}${g}${r}`.toUpperCase();
}

async function getVideoResolution(inputPath) {
  try {
    const out = execSync(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "${inputPath}"`).toString().trim();
    const [w,h] = out.split(',');
    return { width: parseInt(w,10), height: parseInt(h,10) };
  } catch (e) {
    console.warn('ffprobe failed; using fallback 1920x1080');
    return { width: 1920, height: 1080 };
  }
}

// -------------------------
// framesToAss() with conditional extra-down for two-line frames
// -------------------------
function framesToAss(frames, styles = {}, videoWidth, videoHeight) {
  const playResX = videoWidth;
  const playResY = videoHeight;
  const refH = 1080;

  const fontTop = styles.fontTop || 'Lexend';
  const fontBottom = styles.fontBottom || 'Cormorant Garamond';
  const fontSizeTop = styles.fontSizeTop || 40;
  const fontSizeBottom = styles.fontSizeBottom || 52;
  const colorTop = cssToAssColor(styles.colorTop || '#FFFFFF');
  const colorBottom = cssToAssColor(styles.colorBottom || '#FFD100');
  const boldTop = (styles.fontWeightTop === '700') ? '1' : '0';
  const boldBottom = (styles.fontWeightBottom === '700') ? '1' : '0';
  const italicTop = styles.isItalicTop ? '1' : '0';
  const italicBottom = styles.isItalicBottom ? '1' : '0';
  const paddingBottom = styles.paddingBottom || 200;

  // scale metrics to the actual video height
  const scale = playResY / refH;
  const scaledTop = fontSizeTop * scale;
  const scaledBottom = fontSizeBottom * scale;
  const baseGap = 18 * scale; // tuned base gap

  // Tuned baseline heuristics for these fonts/sizes:
  const baselineFactorBottom = 0.65; // portion of bottom font height to reserve above its baseline
  const baselineFactorTop = 0.30;    // portion of top font that visually extends above baseline
  const extraGapFactor = 0.20;       // additional separation as fraction of bottom font size

  // Compute base Y for Line 2 (anchored)
  let Y_pos_Line2 = playResY - (paddingBottom * scale);

  // If ANY frame contains both line1 and line2, we want to push the bottom line down a bit
  // to avoid tiny overlaps when top text exists. This only nudges the bottom line, not single-line frames.
  const twoLinePresent = frames.some(f => f.line1 && f.line1.trim() && f.line2 && f.line2.trim());
  if (twoLinePresent) {
    // extra downward nudge proportional to bottom font height (tune multiplier as needed)
    const extraDownWhenTwoLines = Math.round(scaledBottom * 0.40); // 35% of bottom font size
    Y_pos_Line2 += extraDownWhenTwoLines;
  }

  // Compute Y for Line1 above Line2 (so top never pushes bottom)
  const Y_pos_Line1 = Y_pos_Line2
    - (scaledBottom * baselineFactorBottom)
    - (scaledTop * baselineFactorTop)
    - (baseGap + scaledBottom * extraGapFactor);

  // ASS header and styles
  const shadowColor = '&H80000000';
  const header = `[Script Info]
ScriptType: v4.00+
PlayResX: ${playResX}
PlayResY: ${playResY}
WrapStyle: 0
Title: Generated by AiVideoCaptioner

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: STYLE_BOTTOM,${fontBottom},${fontSizeBottom},${colorBottom},${colorBottom},&H00000000,${shadowColor},${boldBottom},${italicBottom},0,0,100,100,0,0,1,0,2,2,20,20,0,1
Style: STYLE_TOP,${fontTop},${fontSizeTop},${colorTop},${colorTop},&H00000000,${shadowColor},${boldTop},${italicTop},0,0,100,100,0,0,1,0,2,2,20,20,0,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  const centerX = Math.round(playResX / 2);

  const events = frames.flatMap(f => {
    const startSec = (f.start || 0) / 1000;
    const endSec = (f.end || ( (f.start || 0) + 2000 )) / 1000;
    const assStart = secToAss(startSec);
    const assEnd = secToAss(endSec);
    const out = [];

    if (f.line1 && f.line1.trim()) {
      const t1 = f.line1.trim().replace(/\n/g, '\\N');
      out.push(`Dialogue: 0,${assStart},${assEnd},STYLE_TOP,,0,0,0,,{\\an5\\pos(${centerX},${Math.round(Y_pos_Line1)})}${t1}`);
    }
    if (f.line2 && f.line2.trim()) {
      const t2 = f.line2.trim().replace(/\n/g, '\\N');
      out.push(`Dialogue: 0,${assStart},${assEnd},STYLE_BOTTOM,,0,0,0,,{\\an5\\pos(${centerX},${Math.round(Y_pos_Line2)})}${t2}`);
    }
    return out;
  }).join('\n');

  return header + events;
}

// -------------------------
// /render endpoint
// -------------------------
app.post('/render', async (req, res) => {
  try {
    // Auth check
    const headerSecret = req.header('X-Render-Secret');
    const bodySecret = req.body && req.body.render_secret;
    const provided = headerSecret || bodySecret || '';
    if (provided !== RENDER_SECRET) return res.status(401).json({ status: 'error', error: 'unauthorized' });

    const { job_id, video_url, frames, style, callback_url, watermark_url, plan_tier } = req.body || {};
    if (!video_url || !frames) return res.status(400).json({ status: 'error', error: 'missing fields - require video_url and frames' });

    const shouldAddWatermark = plan_tier === 'free';
    const tmpDir = '/tmp';
    const inputPath = path.join(tmpDir, `in-${job_id}.mp4`);
    const assPath = path.join(tmpDir, `subs-${job_id}.ass`);
    const watermarkPath = path.join(tmpDir, `watermark-${job_id}.png`);
    const outPath = path.join(tmpDir, `out-${job_id}.mp4`);

    // 1) Download input video
    try {
      console.log(`Attempting to download video from: ${video_url}`);
      const writer = (await axios({ url: video_url, method: 'GET', responseType: 'stream' })).data;
      const outStream = fsSync.createWriteStream(inputPath);
      await new Promise((resolve, reject) => {
        writer.pipe(outStream);
        writer.on('end', resolve);
        writer.on('error', reject);
      });
    } catch (e) {
      let errorMsg = 'Failed to download video. Please check the URL and access permissions.';
      if (e.response && e.response.status === 403) {
        errorMsg = `Video download failed with HTTP 403 Forbidden. Ensure the video URL (${video_url}) is publicly accessible.`;
      }
      console.error('Download error:', errorMsg, e.message || e);
      return res.status(500).json({ status: 'error', error: errorMsg });
    }

    // 2) Detect video resolution
    const videoResolution = await getVideoResolution(inputPath);
    console.log(`Video Resolution Detected: ${videoResolution.width}x${videoResolution.height}`);

    // 3) Download watermark image if needed
    let watermarkInput = null;
    if (shouldAddWatermark && watermark_url) {
      try {
        const logoWriter = (await axios({ url: watermark_url, method: 'GET', responseType: 'stream' })).data;
        const logoOutStream = fsSync.createWriteStream(watermarkPath);
        await new Promise((resolve, reject) => {
          logoWriter.pipe(logoOutStream);
          logoOutStream.on('close', resolve);
          logoOutStream.on('error', reject);
        });
        watermarkInput = watermarkPath;
      } catch (e) {
        console.warn('Failed to download watermark image (Non-fatal, using text watermark):', e.message || e);
      }
    }

    // 4) Create ASS subtitles (using actual resolution)
    const ass = framesToAss(frames, style || {}, videoResolution.width, videoResolution.height);
    await fs.writeFile(assPath, ass, 'utf8');

    // Watermark & ffmpeg setup
    const WATERMARK_TEXT = "AiVideoCaptioner";
    const WATERMARK_IMAGE_HEIGHT = 28;
    const WATERMARK_TEXT_SIZE = 18;
    const PADDING = 24;

    const assFilter = `ass=filename=${assPath}:fontsdir=/app/fonts`;
    let ffArgs;
    let filterComplex;

    if (shouldAddWatermark) {
      if (watermarkInput) {
        // Input order: 0 = watermark image, 1 = video
        filterComplex = `[0:v]scale=-1:${WATERMARK_IMAGE_HEIGHT}[wm_scaled];[1:v][wm_scaled]overlay=x=main_w-overlay_w-${PADDING}:y=${PADDING}[v_wm];[v_wm]${assFilter}[v]`;
        ffArgs = ['-y', '-i', watermarkInput, '-i', inputPath, '-filter_complex', filterComplex, '-map', '[v]', '-map', '1:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
      } else {
        // fallback text watermark
        const watermarkDrawText = `drawtext=fontfile='Lexend-Regular.ttf':text='${WATERMARK_TEXT}':fontsize=${WATERMARK_TEXT_SIZE}:fontcolor=white@0.7:x=main_w-tw-${PADDING}:y=${PADDING}[v_wm]`;
        filterComplex = `[0:v]${watermarkDrawText};[v_wm]${assFilter}[v]`;
        ffArgs = ['-y', '-i', inputPath, '-filter_complex', filterComplex, '-map', '[v]', '-map', '0:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
      }
    } else {
      filterComplex = `[0:v]${assFilter}[v]`;
      ffArgs = ['-y', '-i', inputPath, '-filter_complex', filterComplex, '-map', '[v]', '-map', '0:a?', '-c:v', 'libx264', '-preset', 'veryfast', '-crf', '23', '-c:a', 'copy', outPath];
    }

    // 5) Run ffmpeg
    try {
      await runFFmpeg(ffArgs);
    } catch (ffErr) {
      console.error('ffmpeg failed:', ffErr);
      return res.status(500).json({ status: 'error', error: 'ffmpeg failed: ' + (ffErr.message || ffErr) });
    }

    // 6) Upload to GCS
    const destName = `renders/${job_id}-${Date.now()}.mp4`;
    let publicUrl;
    try {
      publicUrl = await uploadToGCS(outPath, destName);
    } catch (uerr) {
      console.error('upload failed:', uerr);
      return res.status(500).json({ status: 'error', error: 'upload failed: ' + (uerr.message || uerr) });
    }

    // 7) Optional callback
    if (callback_url) {
      try {
        await axios.post(callback_url, {
          render_secret: RENDER_SECRET,
          job_id,
          status: 'success',
          video_url: publicUrl
        }, { timeout: 10000 });
      } catch (e) {
        console.warn('Callback failed (non-fatal):', e.message || e);
      }
    }

    // 8) Return result
    return res.json({ status: 'success', job_id, video_url: publicUrl });

  } catch (err) {
    console.error('Server error (catch-all):', err);
    return res.status(500).json({ status: 'error', error: err.message || String(err) });
  }
});

const port = process.env.PORT || 8080;
app.listen(port, () => console.log('listening on', port));
